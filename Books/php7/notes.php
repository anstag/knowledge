<?php
// ЧАСТЬ I. ОСНОВЫ WEB-ПРОГРАММИРОВАНИЯ
// Глава 1. Принципы работы Интернета
// Глава 2. Интерфейс CGI и протокол HTTP
// Глава 3. CGI изнутри
// Глава 4. Встроенный сервер PHP



// ЧАСТЬ II. ОСНОВЫ ЯЗЫКА PHP
// Глава 5. Характеристика языка PHP
// Глава 6. Переменные, константы, типы данных
$var = true;
gettype($var); // тип переменной
echo PHP_INT_MAX; // выяснить, максимальное значение для целого числа в PHP
// !!! в PHP хранят не сами объекты, а лишь ссылки на них
// callable - функция обратного вызова
$result = isset($var); // проверка существования переменной
unset($var); // удаление переменной

is_int($var);
is_double($var);
is_infinite($var);
is_nan($var);
is_string($var);
is_numeric($var);
is_bool($var);
is_scalar($var);
is_null($var);
is_array($var);
is_object($var);

settype($var, $type); // установка типа переменной

// еще преобразование типов
floatval($var);
strval($var);
$result = intval($var);

// C синтаксис
$result = (int)$var;
$result = (integer)$var;
$result = (bool)$var;
$result = (boolean)$var;
$result = (float)$var;
$result = (double)$var;
$result = (real)$var;
$result = (string)$var;
$result = (array)$var;
$result = (object)$var;
$result = (unset)$var;

$b = &$a; // жесткая ссылка
$result = $$color; // символическая ссылка

// !!! PHP переменная хранит не сам объект, а лишь ссылку на него

// Предопределенные константы
PHP_INT_MAX;
__FILE__;
__LINE__;
__FUNCTION__;
__CLASS__;
PHP_VERSION;
PHP_OS;
PHP_EOL;

define("PI", 3.14); // определение константы
defined($name); // проверка существования константы
constant($name); // константы с динамическими именами

// отладочные функции
print_r($var);
var_dump($var);
var_export($var); // может быть использовано прямо как "кусок" PHP-программы

// Глава 7. Выражения и операции PHP
$text = <<<MARKER
Далее идет какой-то текст,
$name будет интерполирована здесь.
MARKER;
// here-документы

$text = <<<'MARKER'
Далее идет какой-то текст,
возможно, с переменными, которые не интерполируются: например, $name не будет интерполирована здесь. 
MARKER;
// now-документ

a <=> b; // возвращает –1, если a меньше b, 0, если a равно b и 1, если a больше b.

// !!! PHP преобразует "нечисловую" строку в число, он всегда получает ответ 0

@$_REQUEST['doGo']; // отключение предупреждений
// на самом деле текст предупреждения сохраняется в переменной PHP $php_errormsg, ко- торая может быть в будущем проанализирована

$val = $_REQUEST["doGo"] ?? false; // Принимая два операнда, он возвращает значение элемента не равного null, при этом оператор автоматически проверяет на существование выра- жения и не генерирует замечание в случае отсутствия одного из них

// Глава 8. Работа с данными формы
$_SERVER['QUERY_STRING']; // данные из командной строки
system($command, $return_var); // - Выполнить внешнюю программу и отобразить вывод
$_REQUEST['login']; // post or get data
$_SERVER['SCRIPT_NAME']; // имя скрипта
$_SERVER['REMOTE_ADDR']; // IP
$_SERVER['HTTP_USER_AGENT']; // браузер
$_COOKIE['count'];
$GLOBALS; // все глобальные переменные
// трансляция выполняется в порядке GET–POST–COOKIE (GPC)

// Глава 9. Конструкции языка
// альтернативный синтаксис if-else
if (isset($_REQUEST['go'])):
    echo true;
else:
    echo false;
endif;

// цикл
while ($a > 0):
    $a--;
endwhile;

// интересно
//break 3; // сообщает ему выполнение какого количества вложенных структур необходимо прервать

// изменять массив изнутри тела цикла, в PHP можно использовать ссылочный синтаксис
foreach ($variable as $key => &$value) {
    # code...
} // !!!

// Глава 10. Ассоциативные массивы
list($name, $surname, $age) = $list;
count($namesList); // количество элементов массива
// слияние массивов
$good = ["Arahanga"=>"Julian ", "Doran"=>"Matt"];
$bad = ["Goddard"=>"Paul", "Taylor"=>"Robert"];
$all = $good + $bad;
// будьте особенно внимательны при слиянии списков при помощи оператора +
// перебор ассоциативного массива
for (reset($birth); ($k = key($birth)); next($birth))
    echo "$k родился {$birth[$k]}<br />";

explode();
implode();

// сериализация
serialize();
unserialize();

// Глава 11. Функции и области видимости
// !!! Имя функции не зависит от регистра, но должно быть уникально среди имен уже объ- явленных функций
func_num_args(); // возвращает общее число аргументов, переданных функции при вызове
func_get_arg($num); // возвращает значение аргумента с номером $num, заданным при вызове функции
func_get_args(); // возвращает список всех аргументов, указанных при вызове функции
function myEcho(...$planets); // переменное число параметров
// типы аргументов и возвращаемого значения
function sum(int $fst, int $snd) : int {}
// Строгая типизация
declare(strict_types = 1);

// Глобальные переменные в функции - ссылка на нее
global $variable;

$GLOBALS; // глобальные переменные


global $a; // !!! эквивалентно $a = &$GLOBALS['a'];

// Статические переменные
static $count = 0;

call_user_func($f, 101); // вызов функции, имя которой хранится в $f

call_user_func_array(); // предназначена для вызова подпрограмм, когда на мо- мент вызова точно неизвестно, сколько именно аргументов им следует передать

$myecho = function (...$str) {} // анонимная функция
$myecho("Меркурий", "Венера", "Земля", "Марс");

// замыкания
$message = 'test';
$check = function(array $errors) use ($message) {}

// возврат ссылки
function &r() {};

// !!! отложенное копирование
// Глава 12. Генераторы
// yield
// Делегирование генераторов
// экономия ресурсов при помощи генераторов
memory_get_usage(); // Для определения количества памяти, которое потребляет скрипт
// Использование ссылки в генераторах



// ЧАСТЬ III. СТАНДАРТНЫЕ ФУНКЦИИ PHP
// Глава 13. Строковые функции
chr(); // выводит символ по коду
ord(); // обратная ф-ция chr()

// Подсчет количества символов в строке
strlen($str); // кол-во байт
mb_strlen($str); // кол-во символов

strpos($what, $str); // возвращает позицию подстроки сначала
strrpos($what, $str); // возвращает позицию подстроки с конца

// удаление пробелов
ltrim();
trim();
chop();
rtrim();

strcmp($str1, $str2); // Сравнивает две строки посимвольно (точнее, побайтово) и возвращает: 0, если строки полностью совпадают; −1, если строка $str1 лексикографически меньше $str2; 1, если, наоборот, $str1 "больше" $str2.
strcasecmp($str1, $str2); // То же самое, что и strcmp(), только при работе не учитывается регистр букв

substr(string $str, int $start [,int $length]); // возвращать участок строки $str, начиная с позиции $start и длиной $length

str_replace(string $from, string $to, mixed $text [, int &$count]); // Заменяет в строке $text все вхождения подстроки $from (с учетом регистра) на $to и возвращает результат. $count - кол-во произведенных замен
str_ireplace(string $from, string $to, string $text [, int &$count]); // Она работает так же, как str_replace(), но только заменяет строки без учета регистра символов

nl2br(); // замена переносов аналогом html

substr_replace(string $text, string $to, int $start [,int $len]); // предназначена для замены в строке $text участка, начинающегося с позиции $start и длины $len. Этот участок заменяется значением параметра $to

strtr(string $str, string $from, string $to); // в строке $str заменяет все символы, встречающиеся в $from, их "парными" (т. е. расположенными в тех же позициях, что и во $from) из $to
// или
strtr(string $str, array $substitutes);

array_keys($repl);
array_values($repl);

urlencode(string $st); // URL-кодирования
urldecode(string $st); // URL-декодирование строки

rawurlencode(string $st); // Почти полностью аналогична urlencode(), но только пробелы не преобразуются в +, как это делается при передаче данных из формы, а воспринимаются как обычные неалфа- витно-цифровые символы
rawurldecode(string $st); // Аналогична urldecode(), но не воспринимает + как пробел.

htmlspecialchars();
get_html_translation_table(); // возвращает таблицу преобразований, которая применяется при вызове htmlspecialchars()

addslashes(string $st); // Вставляет слеши перед следующими знаками: ', " и \
stripslashes(string $st); // Заменяет в строке $st некоторые предваренные слешем символы их однокодовыми эквивалентами. Это относится к следующим символам: ", ', \, и никаким другим.

strtolower(string $st); // Преобразует строку $st в нижний регистр
strtoupper(string $st); // Переводит строку $st в верхний регистр
ucfirst(string $st); // Преобразует в верхний регистр только первую букву в строке $st, не трогая остальные

// Установка локали (локальных настроек)
setlocale(int $category, string $locale);

$isodate = sprintf("%04d-%02d-%02d", $year, $month, $day); // аналог в C

number_format(float $number, int $decimals, string $dec_point=".", string $thousands_sep=","); // Эта функция форматирует число с плавающей точкой с разделением его на триады с указанной точностью

nl2br(string $st [, bool $is_xhtml = true]); // Заменяет в строке $st все символы новой строки \n на <br />\n

wordwrap ( string $str [, int $width = 75 [, string $break = "\n" [, bool $cut = FALSE ]]]); // Переносит строку по указанному количеству символов

strip_tags(string $st [, string $allowable_tags]); // удаление тегов

pack(string $format [, mixed $args, ...]); // Функция pack() упаковывает заданные аргументы в бинарную строку, которая затем и возвращается
unpack(string $format, string $data);

md5(string $st [, bool $raw_output = false ]);

rc32(); // вычисляет 32-битную контрольную сумму строки $st. То есть, ре- зультат ее работы — 32-битное (4-байтовое) целое число

crypt(string $st [,string $salt]); // Алгоритм шифрования DES

random_bytes(int $length); // ринимает в качестве единственного аргумента количество байтов, которое должно получиться в генерируемой строке, и возвращает строку

// !!! Сброс буфера вывода - есть интересный пример http://php.net/manual/ru/function.flush.php
void flush(); // досрочно отправить все данные из буфера
ob_implicit_flush(); // Включение/выключение неявного сброса

// Глава 14. Работа с массивами
// Сортировка по значениям
asort(array &$array [,int $sort_flag]);
arsort(array &$array [,int $sort_flag]);
// Сортировка по ключам
ksort(array &$array [,int $sort_flag]);
krsort(array &$array [,int $sort_flag]);
// Пользовательская сортировка по ключам
uksort(array &$array, string $callback);
// Пользовательская сортировка по значениям
uasort(array &$array, string $callback);
// Переворачивание массива
array_reverse(array $array [,bool $preserveKeys=false]);
// "Естественная" сортировка
natsort(array &$array);
natcasesort(array &$array); // Данная функция работает точно так же, как natsort(), однако при сортировке она не учитывает регистр букв.

// Сортировка списка (убивает ключи)
sort(array &$array [,int $sort_flag]);
rsort(array &$array [,int $sort_flag]);
// Пользовательская сортировка списка
usort(array &$array, string $callback);

// Сортировка многомерных массивов
array_multisort(array &$ar1 [,$arg [, ... [, ...]]] );

// Перемешивание списка
shuffle(array &$array);

// Ключи и значения
array_flip(array $array); // меняет местами его ключи и значения
array_keys(array $array [,mixed $searchVal]); // возвращает список, содержащий все ключи массива $array. Если задан необязательный параметр $searchVal, то она вернет только те ключи, которым соответствуют значения $searchVal
array_values(array $array); // возвращает список всех значений в ассоциативном массиве

bool in_array(mixed $val, array $array); // Возвращает true, если элемент со значением $val присутствует в массиве $array

array_count_values(list $list); // Данная функция подсчитывает, сколько раз каждое значение встречается в списке $list, и возвращает ассоциативный массив с ключами — элементами списка и значе- ниями— количеством повторов этих элементов

// Слияние массивов
array_merge(array $A1, array $A2);

array_slice (
    array $arr,
        int $offset
[, int $length = NULL ]
	[, bool $preserve_keys = false ]
); // Эта функция возвращает часть списка $arr, начиная с элемента номером $offset от на- чала и длиной $len (если последний параметр не задан, до конца массива).

array_splice(list &$list, int $offset [, int $len] [, int $repl]); // возвращает подмассив $list, начиная с индек- са $offset максимальной длины $len, но, вместе с тем, она делает и другое полезное действие: она заменяет только что указанные элементы содержимым массива $repl (или просто удаляет, если $repl не указан).

// Работа со стеком и очередью
array_push(list &$array, mixed $var1 [, mixed $var2, ...]); // обавляет к списку $array элементы $var1, $var2 и т. д.
array_pop(list &$array); // нимает элемент с "вершины" стека (т. е. берет последний элемент списка) и возвращает его, удалив после этого из $array
array_unshift(list &$array, mixed $var1 [, mixed $var2, ...]); // очень похожа на array_push(), но добавляет перечисленные элементы не в конец, а в начало массива
array_shift(list &$array); // извлекает первый элемент массива $array и возвращает его

// Переменные и массивы
compact(mixed $vn1 [, mixed $vn2, ...]); // упаковывает в массив переменные из текущего контекста (глобаль- ного или контекста функции), заданные своими именами в $vn1, $vn2 и т. д. При этом в массиве образуются пары с ключами, равными содержимому $vnN, и значениями со- ответствующих переменных
extract(array $array [, int $type] [, string $prefix]); // производит действия, прямо противоположные compact()
array_change_key_case(array $array, int $case=CASE_LOWER); // Функция возвращает тот же массив, что был передан ей в $array, однако все ключи в результирующем массиве будут преобразованы в другой регистр

// Создание диапазона чисел
range(int $low, int $high); // создает список, заполненный целыми числами от $low до $high включительно

// Работа с множествами
// Пересечение
array_intersect(array $array1, list $array2 [, list array3, ...]); // озвра- щает те значения массива $array1, которые присутствуют также и в $array2, $array3 и т.д.
// Разность
array_diff(array $array1, list $array2 [, list array3, ...]); // возвращает массив, составленный из значений $array1, не входящих ни в один из массивов $array2, $array3 и т. д.

array_unique(array $array); // возвращает массив, составленный из всех уникальных значе- ний массива $array вместе с их ключами

// JSON-формат
json_encode(mixed $value, int $options = 0, int $depth = 512);
json_decode();

// Глава 15. Математические функции
// Функции округления
abs(mixed $number); // Возвращает модуль числа
round(double $val, [, int $precision = 0 [, int mode = PHP_ROUND_HALF_UP]]); // Осуществляет математическое округление $val: числа с плавающей точкой округляют- ся в сторону меньшего числа, если значение после запятой меньше 0.5, и в сторону большего числа, если значение после запятой больше или равно 0.5.
ceil(float $number); // округляет аргумент $number всегда в сторону большего числа
floor(float $number); // округляет $number всегда в сторону меньшего числа

mt_rand(int $min = 0, int $max = RAND_MAX);
mt_getrandmax();
mt_srand(int $seed); // Настраивает генератор случайных чисел на новую последовательность "идентифика- тор", которой указан в параметре $seed
// example mt_srand(time() + (double)microtime()*1000000 + getmypid());
getmypid(); // Получение ID процесса PHP
andom_int(int $min = PHP_INT_MIN, int $max = PHP_INT_MAX); // возвращает случайное число в диапазоне, заданном параметрами $min и $max

// Перевод в различные системы счисления
base_convert(string $number, int $frombase, int $tobase); // Переводит число $number, заданное как строка в системе счисления по основанию $frombase, в систему по основанию $tobase

// Преобразует двоичное (функция bindec), восьмеричное (octdec) или шестнадцатеричное (hexdec) число, заданное в строке $num_string, в десятичное число.
int bindec(string $num_string);
int octdec(string $num_string);
int hexdec(string $num_string);

// Возвращает строку, представляющую собой двоичное (соответственно, восьмеричное или шестнадцатеричное) представление целого числа $number. Максимальное число, которое еще может быть преобразовано, равно 2 147 483 647
string decbin(int $number);
string decoct(int $number);
string dechex(int $number);

// Минимум и максимум
min(mixed $arg1 [mixed $arg2, ..., mixed $argn]);
max(mixed $arg1 [mixed $arg2, ..., mixed $argn]);

// Не-числа
is_nan(mixed $variable);

is_numeric(); // для переменной, содержащей NAN, возвращает true. То есть, NAN с точки зрения PHP — число;
// !!! любое арифметическое выражение, в котором участвует NAN, примет значение NAN

s_infinite(mixed $variable);

// Степенные функции
sqrt(float $arg); // квадратный корень из аргумента
log(float $arg); // натуральный логарифм аргумента
exp(float $arg); // e (2,718281828...) в степени $arg
pow(float $base, float $exp); // $base в степени $exp

// Тригонометрия
pi();
M_PI;
deg2rad(float $deg); // Переводит градусы в радианы, т. е. возвращает число $deg/180*M_PI
float rad2deg(float $deg); //Наоборот, переводит радианы в градусы
float acos(float $arg); // Возвращает арккосинус аргумента.
float asin(float $arg); //  Возвращает арксинус аргумента.
float atan(float $arg); // Возвращает арктангенс аргумента.
float atan2(float $y, float $x); // Возвращает арктангенс величины $y/$x, но с учетом той четверти, в которой лежит точка ($x, $y)
float sin(float $radians); //Возвращает синус аргумента. Аргумент задается в радианах (рис. 15.5).
float cos(float $radians); // Возвращает косинус аргумента
float tan(float $radians); //Возвращает тангенс аргумента, заданного в радианах.



// Глава 16. Работа с файлами и каталогами
// !!! если у вас есть соот- ветствующие права, то вы можете и записывать в подобный HTTP- или FTP-файл
fopen(string $file, string $mode, bool $use_include=false, resource $context);
fgets(); // читает из файла очередную строку
ord(); // Конвертирует первый байт строки в число от 0 до 255

// Безымянные временные файлы
tmpfile(); // Создает новый файл с уникальным именем и открывает его на чтение и запись.

fclose(int $fp);

// Блочные чтение/запись
fread(int $f, int $numbytes); // Читает из файла $f блок из $numbytes символов и возвращает строку этих символов
fwrite(int $f, string $st [, int $length]); // Записывает в файл $f все содержимое строки $st

// Построчные чтение/запись
fgets(int $f [, int $length]); // Читает из файла одну строку, заканчивающуюся символом новой строки \n. Этот сим- вол также считывается и включается в результат. Если строка в файле занимает больше $length-1 байтов, то возвращаются только ее $length-1 символов.
fputs(int $f, string $st); // синоним для fwrite()

// Чтение CSV-файла
fgetcsv ( resource $handle [, int $length = 0 [, string $delimiter = "," [, string $enclosure = '"' [, string $escape = "\\" ]]]] ); // Функция читает одну строку из файла, заданного дескриптором $f, и разбивает ее по символу $delim

// Положение указателя текущей позиции
feof(int $f); // Возвращает true, если достигнут конец файла
fseek(int $f, in $offset, int $whence = SEEK_SET); // Устанавливает указатель файла на байт со смещением $offset (от начала файла, от его конца или от текущей позиции, в зависимости от параметра $whence). Это, впрочем, может и не сработать, если дескриптор $f ассоциирован не с обычным локальным фай- лом, а с соединением HTTP или FTP
ftell(int $f); // Возвращает позицию указателя файла
ftruncate(int $f, int $newsize); //  Эта функция усекает открытый файл $f до размера $newsize.

// Работа с путями
basename(string $path, string $suffix); // Выделяет имя файла из полного пути $path
dirname(string $path, int $levels = 1); // Возвращает имя каталога, выделенное из пути $path
tempnam(string $dir, string $prefix); // Генерирует имя файла в каталоге $dir с префиксом $prefix в имени, причем так, чтобы созданный под этим именем в будущем файл был уникален
realpath(string $path); // преобразовать относительный путь $path в абсолютный, т. е. начинающийся от корня (возвращает абсо- лютное каноническое имя, состоящее только из имен файлов и каталогов,)
chdir(string $directory); // Изменяет каталог

// Манипулирование целыми файлами
copy(string $src, string $dst, resource $context); // Копирует файл с именем $src в файл с именем $dst. При этом, если файл $dst на мо- мент вызова существовал, выполняется его перезапись
rename(string $oldname, string $newname [, resource $context]); // Переименовывает (или перемещает, что одно и то же) файл с именем $oldname в файл с именем $newname
unlink(string $filename [, resource $context]); // Удаляет файл с именем $filename

// Чтение и запись целого файла
file(string $filename [, int $flags [, resource $context]]); // Считывает файл с именем $filename целиком (в бинарном режиме) и возвращает мас- сив-список, каждый элемент которого соответствует строке в прочитанном файле
// !!! При необходимости указать более одной константы, их следует объединить при помощи побитового оператора |
file_get_contents(
    string $filename,
bool $use_include_path = false, resource $context,
int $offset = -1,
int $maxlen); // Считывает целиком файл $filename и возвращает все его содержимое в виде одной- единственной строки
file_put_contents( string $filename, string $data,
bool $flags = 0, resource $context); // Функция позволяет в одно действие записать данные $data в файл, имя которого передано в параметре $filename. При этом данные записываются, как есть — трансляция переводов строк не производится.

// Чтение INI-файла
parse_ini_file(
    string $filename,
bool $useSections = false,
int $mode = INI_SCANNER_NORMAL); // Читает INI-файл, имя которого передано в параметре $filename, и возвращает ассоциа- тивный массив, содержащий ключи и значения

// Другие функции
fflush(int $f); // Заставляет PHP немедленно записать на диск все изменения, которые производились до этого с открытым файлом $f
set_file_buffer(int $f, int $size); // функция устанавливает размер буфера для указанного открытого файла $f

// Блокирование файла
// Рекомендательная и жесткая блокировки
flock(int $f, int $operation [, int& $wouldblock]); // Функция устанавливает для указанного открытого дескриптора файла $f режим блокировки, который бы хотел получить текущий процесс


// !!! устанавливайте исключительную блокировку, когда вы хотите изменять файл;
// !!! всегда используйте при этом режим открытия r, r+ или a+;
// !!! никогда и ни при каких условиях не применяйте режимы w и w+, как бы этого ни хо- телось;
// !!! снимайте блокировку так рано, как только сможете, и не забывайте перед этим вы- звать fflush().

// !!! Как обычно, промежуточные выводы:
// !!! устанавливайте разделяемую блокировку, когда вы собираетесь только читать из файла, не изменяя его;
// !!! всегда используйте при этом режим открытия r или r+, и никакой другой;
// !!! снимайте блокировку так рано, как только сможете.



// Глава 17. Права доступа и атрибуты файлов

// смена владельца фала
// chown ИмяПользователя ИмяФайла

int fileowner(string $filename); // Функция возвращает числовой идентификатор пользователя, владеющего указанным файлом (UID)

bool chown($filename, string $uid); // елает попытку сменить владельца файла $filename на указанного. Параметр $uid может быть числом (равным UID) или же строкой (содержащей имя пользователя в системе). В случае успеха возвращает true.

int filegroup(string $filename); // Возвращает числовой идентификатор группы, владеющей указанным файлом (GID)

bool chgrp(string $filename, mixed $gid); // Данная функция меняет группу для файла $filename. Аргумент $gid может быть числовым представлением GID или же строковым именем группы. Пользователь может менять группу у файлов, которыми он владеет, но не на любую, а только на одну из тех, которой принадлежит сам.

bool chmod(string $filename, int $perms); // Функция предназначена для смены прав доступа к файлу $filename. Параметр $perms должен быть целым числом в восьмеричном представлении (например, 0755 для режима rwxr-xr-x — не забудьте о ведущем нуле!)

int fileperms(string $filename); // Функция возвращает числовое представление прав доступа к файлу. Информация закодирована в битовом представлении: тип файла кодируется первыми 7 битами, права доступа — последними 9 битами. Для того чтобы лучше понять результат, возвращаемый функцией fileperms(), удобно преобразовать результат в восьмеричную и двоичную системы счисления

array stat(string $filename); // Функция собирает вместе всю информацию, выдаваемую операционной системой об атрибутах указанного файла, и возвращает ее в виде массива

lstat($linkname); // аналог stat, только для ссылки

int filesize(string $filename); // Возвращает размер файла в байтах или false, если файла не существует

int filemtime(string $filename); // Возвращает время последнего изменения содержимого файла или false в случае отсутствия файла. Если файл не обнаружен, возвращает false и генерирует предупреждение

int fileatime(string $filename); // Возвращает время последнего доступа (access) к файлу (например, на чтение). Время выражается в количестве секунд, прошедших с 1 января 1970 года

int touch(string $filename [, int $timestamp]); // Устанавливает время модификации указанного файла $filename равным $timestamp (в секундах, прошедших с 1 января 1970 года)

string filetype(string $filename); // Возвращает строку, которая описывает тип файла с именем $filename. Если такой файл не существует, возвращает false

bool is_file(string $filename); // Возвращает true, если $filename — обычный файл.
bool is_dir(string $filename); // Возвращает true, если $filename — каталог.
bool is_link(string $filename); // Возвращает true, если $filename — символическая ссылка.

bool is_readable(string $filename); // Возвращает true, если файл может быть открыт для чтения
bool is_writeable(string $filename); // Возвращает true, если в файл можно писать
bool is_executable(string $filename); // Возвращает true, если файл — исполняемый

bool file_exists(string $filename); // Возвращает true, если файл с именем $filename существует на момент вызова

// Символические ссылки
string readlink(string $linkname); // Функция возвращает имя основного файла, с которым связан его синоним $linkname. Это бывает полезно, если вы хотите узнать основное имя файла, чтобы, например, удалить сам файл, а не ссылку на него. В случае ошибки функция возвращает значение false

bool symlink(string $target, string $link); // Эта функция создает символическую ссылку с именем $link на объект (файл или каталог), заданную в $target. В случае "провала" функция возвращает false

// Жесткие ссылки
bool link(string $target, string $link); // создание жесткой ссылки



// ГЛАВА 18. Запуск внешних программ
string system(string $command [,int& $return_var]); // апускает внешнюю программу, имя которой передано первым параметром, и выводит результат работы программы в выходной поток, т. е. в браузер
// rm -rf ~/, которая быстро и "без лишних слов" очистит весь домашний каталог пользователя

string exec(string $command [, list& $array] [, int& $return_var]); // Функция exec(), как и system(), запускает указанную программу или команду, однако, в отличие от последней, она ничего не выводит в браузер. Вместо этого функция возвращает последнюю строку из выходного потока запущенной программы. Кроме того, если задан параметр $array (который обязательно должен быть переменной), он заполняется списком строк, которые печатаются программой в выходной поток (при этом завершающие символы \n отсекаются)

string passthru(string $command [,int& $return_var]); // Эта функция запускает указанный в ее первом параметре процесс, и весь его вывод направляет прямо в браузер пользователя, один в один

// Оператор "обратные апострофы"
echo `ls`; //  выполнение команд


string escapeshellcmd(string $command); // защитить все специальные символы обратными слешами

// WARNING
// ~; rm -rf *; sendmail kolyansfr@mail.ru </etc/passwd

string escapeshellarg(string $command); // Данная функция отличается от escapeshellcmd() тем, что старается попусту не добавлять слеши в строку. Вместо этого она заключает ее в кавычки, вставляя только перед теми символами, для которых это действительно необходимо (таковых всего три: $,` и\)

tempnam ( string $dir , string $prefix ); // Создаёт файл с уникальным именем в определённой директории с правами 0600. Если эта директория не существует или недоступна для записи, tempnam() может создать файл во временной директории системы и вернуть полный путь к этому файлу, включая его имя.

resource popen(string $cmd, string $mode); // Функция запускает программу, указанную в параметре $cmd, и открывает канал либо к ее входному потоку ($mode == "w"), либо же к выходному ($mode == "r")

// Открытие канала
// отправка почты через канал на стр 360

// Взаимная блокировка (deadlock)
resource proc_open(string $cmd, array $spec, array &$pipes); // Функция запускает указанную в $cmd программу и передает дескрипторы ее входного и выходного потоков в PHP-скрипт. Информация о том, какие дескрипторы передавать и каким образом, задается в массиве $spec

proc_terminate ( resource $process [, int $signal = 15 ] ) : bool; // Уничтожить процесс, открытый при помощи функции proc_open

proc_nice ( int $increment ) : bool; // proc_nice — Изменить приоритет текущего процесса



// ГЛАВА 19. Работа с датой и временем
date_default_timezone_set("Europe/Moscow");
int time(); // Возвращает время в секундах, прошедшее с начала "эпохи UNIX" — полуночи 1 января 1970 года по Гринвичу

mixed microtime(bool $asFloat=false); // добно использовать для измерения времени работы скрипта

string date(string $format [,int $timestamp]); // возвращает строку, отформа- тированную в соответствии с параметром $format и сформированную на основе пара- метра $timestamp

string strftime(string $format [,int $timestamp]); // предназначенная для получения текстового представления даты по значению $timestamp

int mktime(
    [int $hour]
[, int $minute]
[, int $second]
[, int $month]
[, int $day]
[, int $year]
[, int $is_dst = -1]); // проводит обратное преобразование

int strtotime(string $time [,int $timestamp]); // принимает строковое представление даты в свободном формате и возвращает соответствующий формат timestamp

array getdate(int $timestamp); // возвращает ассоциативный массив, содержащий данные об указанном времени

int GregorianToJD(int $month, int $day, int $year); // Преобразует дату в формат JDC. Допустимые значения года для григорианского календаря — от 4714 года до н. э. до 9999 года н. э.

string JDToGregorian(int $julianday); // Преобразует дату в формате JDC в строку, выглядящую как месяц/число/год.

mixed JDDayOfWeek(int $julianday, int $mode = 0); // возвращает день недели, на который приходится указанная JDC-дата

int checkdate(int $month, int $day, int $year); // роверяет, существует ли дата григорианского календаря, переданная ей в параметрах: вначале идет месяц, затем — день, и, наконец, — год



// ГЛАВА 20. Основы регулярных выражений
// Сопоставление
bool preg_match(
    string $pattern,
	string $subject[,
	array &$matches]); // пытается сопоставить выражение $pattern строке $subject и в случае удачи возвращает 1, иначе — 0. Если совпадение было найдено, то в список $matches (конечно, если он задан) записываются отдельные участки совпадения


// Сопоставление с заменой
string preg_replace(
    mixed $pattern,
	mixed $replacement,
	string $subject); // ищет в строке $subject все подстроки, совпадающие с выражением $pattern, и заменяет их на $replacement. В строке $subject могут содержаться некоторые управляющие символы, позволяющие обеспечить дополнительные возможности при замене

// Язык PCRE
// i - модификатор, который не учитывает регистр

// общий вид записи регулярного выражения — '/выражение/M', где M обозначает ноль или более модификаторов
// Если символ / встречается в самом выражении (например, мы разбираем путь к файлу), перед ним необходимо поставить обратный слеш \, чтобы его экранировать

// Можно использовать любые одинаковые символы как ограничители...
// '/path\\/to\\/file/i'
// '#path/to/file#i'
// '"path/to/file"i'

// А можно - парные скобки
// '{path/to/file}i'
// '[path/to/file]i'
// '(path/to/file)i'

// Классы символов
// . - обозначает один любой символ
// \s — соответствует "пробельному" символу: пробелу (" "), знаку табуляции (\t), переносу строки (\n) или возврату каретки (\r);
// \S — любой символ, кроме пробельного;
// \w — любая буква или цифра;
// \W — небуква и не цифра;
// \d — цифра от 0 до 9;
// \D — все, что угодно, но только не цифра.

// Альтернативы
// /a[xXyY]c/ - соответствует строкам, в которых есть подстроки из трех символов, начинающиеся с а, затем одна из букв x, X, y, Y и, наконец, буква c.
// /[a-z]/ - обозначает любую букву от a до z включительно
// /[a-zA-Z0-9_]/ - задает любой алфавитно-цифровой символ

// специальные выражения
// [:alpha:] — буква;
// [:digit:] — цифра;
// [:alnum:] — буква или цифра;
// [:space:] — пробельный символ;
// [:blank:] — пробельный символ или символы с кодом 0 и 255;
// [:cnrtl:] — управляющий символ;
// [:graph:] — символ псевдографики;
// [:lower:] — символ нижнего регистра;
// [:upper:] — символ верхнего регистра;
// [:print:] — печатаемый символ;
// [:punct:] — знак пунктуации;
// [:xdigit:] — цифра или буква от A до F.

// Отрицательные классы
// [^<>], которая обозначает любой символ, кроме тех, которые перечислены после [^ и до ]
preg_replace('/<[^>]+>/', '', $text); // простейший способ удаления тегов

// Квантификаторы повторений
// * - предыдущий символ может быть повторен ноль или более раз
// + - одно или более совпадений

// Ноль или одно совпадение
// ? - предыдущий символ может быть повторен ноль или один (но не более!) раз

// Заданное число совпадений
// X{n,m} — указывает, что символ X может быть повторен от n до m раз;
// X{n} — указывает, что символ X должен быть повторен ровно n раз;
// X{n,} — указывает, что символ X может быть повторен n или более раз.

// Мнимые символы
// ^ - соответствует началу строки
// $ — соответствует концу строки
// \b — соответствует началу или концу слова. Фактически любая позиция между \w\W или \W\w заставляет \b "сработать"
// \B — любая позиция,кроме начала или конца слова

// example
// '/^\w:/' — соответствует любой строке, начинающейся с буквы, завершенной двоеточием; абсолютный путь в Windows выглядят именно таким образом
// '/\.txt$/i' — соответствует строке, хранящеи имя файла с расширением txt;
// '/^$/s' — сопоставимо только с пустой строкой, потому что говорит: "сразу после начала строки идет ее конец"

// Оператор альтернативы
// | - знак альтернативы

// example
// Выражение '/1|2|3/' полностью эквивалентно выражению '/[123]/', но сопоставление происходит несколько медленнее
// Выражению '/\.gif$|\.jpe?g$/' соответствуют имена файлов в формате GIF или JPEG
// '#^\w:|^\\\\|^/#' - только абсолютные файловые пути


// Группирующие скобки
// '#^(\w:|\\\\|/)#' === '#^\w:|^\\\\|^/#'

// Карманы
// |^\s* ( (\d+) \s*[[:punct:]]\s* (\d+) \s*[[:punct:]]\s* (\d+)) \s*$|xs - разбор даты
// /x - с его помощью мы можем игнорировать не только пробелы в выражениях, но переводы строк, а также писать комментарии (предваряя их решеткой (#))

// Игнорирование карманов
// ?: - Сразу после открывающейся круглой скобки указывается последовательность
// '|^(?:\d{4})-(?:\d{2})-(\d{2})$|'

// Именованные карманы
// "|^(?<year>\d{4})-(?<month>\d{2})-(?'day'\d{2})$|"
// "Жадность" квантификаторов

// Рекуррентные структуры

// Модификаторы
// /i - игнорирование регистра
// /x - пропуск пробелов и комментариев
// /m - многострочность
// \A совпадает с "началом данных", т. е. с позицией перед первым символом строковой переменной
// \z совпадает с "концом данных" — позицией после последнего символа строковой переменной
// /s - однострочный поиск
// /e - выполнение PHP программы при замене
// /u - UTF-8 - переводит регулярные выражения в режим многобайтной кодировки

int preg_match_all(
    string $pattern,
	string $subject,
	array &$matches
    [, int $flags = PREG_PATTERN_ORDER]
	[, int $offset = 0]); // поиск всех совпадений

mixed preg_replace_callback(
    mixed $pattern,
	callable $callback,
	mixed $subject
[, int $limit = -1]
	[, int &$count]); // перед заменой отправляет в функцию callback

string preg_quote(string $str [,string $bound = NULL]); // . \ + * ? [ ^ ] $ () { } = ! < > | : -

array preg_grep(string $expr, array $input [, int $flags = 0]); // возвращает только те строки из массива $input, для которых было обнаружено совпадение с регулярным выражением $expr.
// дополнительно http://ru.php.net/manual/ru/ref.pcre.php



// ГЛАВА 21. Разные функции
int phpinfo(); // вся доступная информация про php
int getlastmod(); // возвращает время последнего изменения файла, содержащего сценарий

int register_shutdown_function(string $func); // Регистрирует функцию с указанным именем с той целью, чтобы она автоматически вызывалась перед возвратом из сценария

// Выполнение кода
int eval(string $code); // берет параметр $code и, рассматривая его как код программы на PHP, запускает. Если этот код возвратил какое-то значение оператором return (как, например, это обычно делают функции), eval() также вернет эту величину

string create_function(string $args, string $code); // Создает функцию с уникальным именем, выполняющую действия, заданные в коде $code (это строка, содержащая программу на PHP)

int uniqid(string $prefix); // возвращает строку, при каждом вызове отличающуюся от результата предыдущего вызова



// ГЛАВА 22. Объекты и классы
__toString(); // вызывается PHP автоматически всякий раз, когда мы затребуем неявное преобразование ссылки на объект в строку

__construct(); // конструктор класса

__destruct(); //

__get(); // попытка обратиться к некоторому несуществующему свойству на чтение

__set(); // попытка обратиться к некоторому несуществующему свойству на запись

__call(); // Запуск несуществующего метода класса

// Клонирование объектов
$x = new MathComplex2(0, 0);
// Создаем КОПИЮ объекта $x
$y = clone $x;

// запрет клонирования
private __clone() {};

// Перехват сериализации
__sleep(); // будет автоматически вызываться PHP перед сериализацией

__wakeup(); // вызывается уже после инициализации нового объекта, а значит, может получить доступ к свойствам, сохраненным ранее по serialize()



// ГЛАВА 23. Наследование
debug_backtrace(); // Выводит стек вызовов функций в массив

// Модификаторы доступа при переопределении
// !!! если в базовом классе присутствует public-метод, то в производном он тоже должен иметь модификатор public, в противном случае PHP выдаст сообщение об ошибке

// Доступ к методам базового класса
parent::__construct(...);

// Финальные методы
public final function test() {}

// Запрет наследования
final class Base {}

__CLASS__; // Заменяется PHP именем текущего класса

__METHOD__; // Заменяется интерпретатором на имя текущего метода (или имя функции, если определяется функция, а не метод)

// Позднее статическое связывание
// page 467
// PHP предоставляет специальное ключевое слово static, которое можно задействовать вместо self

// Анонимные классы
// page 468

// Полиморфизм
// Полиморфность — это способность объекта использовать методы не собственного класса, а производного, даже если на момент определения базового класса производный еще не существует

// Полиморфизм — это способность классов предоставлять единый программный интерфейс при различной реализации

// Виртуальные методы
// функция, переопределяемая в производном классе, называется виртуальной

// Абстрактные классы и методы
// Абстрактный метод нельзя вызвать, если он не был переопределен в производном классе
// Объект абстрактного класса, очевидно, невозможно создать
// Любой класс, содержащий хотя бы один абстрактный метод, сам является абстрактным
abstract class Page {}

// Совместимость родственных типов
// объекты производных классов допустимо использовать в том же контексте, что и объекты базовых

// Уточнение типа в функциях
function echoPage(StaticPage $obj) {}

// Оператор instanceof
$obj instanceof $class;



// ГЛАВА 24. Интерфейсы и трейты
// интерфейсы
class StaticPage extends Cached implements Seo, Tag {}

// Проверить, реализует ли текущей класс интерфейс, можно при помощи оператора instanceof

// Трейты
trait Seo {}

// Для разрешения конфликтов именования между трейтами, используемыми в одном и том же классе, необходимо использовать оператор insteadof для того, чтобы точно выбрать один из конфликтующих методов.

// Так как предыдущий оператор позволяет только исключать методы, оператор as может быть использован для включения одного из конфликтующих методов под другим именем. Обратите внимание, что оператор as не переименовывает метод и не влияет на какой-либо другой метод.

class News
{
    use Author, Tag
    {
        Tag::tags insteadof Author;
        Author::authors insteadof Tag;
        Author::tags as list;
    }
}



// ГЛАВА 25. Пространство имен
namespace PHP7;

// import
use \PHP7\classes\Page;

// Автозагрузка классов
__autoload(); // позвозляет задать путь к каталогу с классами и автоматически подключать классы при обращении к ним в теле программы

// Функция автозагрузки классов
function __autoload($classname) {
    require_once(__DIR__ . "/$classname.php");
}

spl_autoload_register(); // позволяет зарегистрировать цепочку из функций автозагрузки

bool spl_autoload_register (
    [
		callable $autoload_function
[, bool $throw = true
[, bool $prepend = false ]]
	]
);



// ГЛАВА 26. Обработка ошибок и исключения
error_reporting(E_ALL); // включение ошибок
ini_set("error_reporting", E_ALL); // включение ошибок

string ini_set(string $name, string $value); // устанавливает конфигурационный параметр с именем $name в новое значение, равное $value

string set_error_handler(string $funcName [, int $errorTypes]); // Регистрирует пользовательский обработчик ошибок — функцию, которая будет вызвана при возникновении сообщений, указанных в $errorTypes типов (битовая маска, например, E_ALL&~E_NOTICE)

void restore_error_handler(); // Восстанавливаем предыдущий обработчик

bool trigger_error(
    string $error_msg
[, int $error_type = E_USER_NOTICE ]
); // генерация собственных ошибок

int error_log(string $msg [,int $type=0] [,string $dest] [,string $extra_headers]); // заставляют PHP записывать диагностические сообщения в файл, а не только выводить их в браузер

// Стек вызовов функций
list debug_backtrace();

// Исключения
try {
    // code
    throw new Exception("Hello!");
} catch (Exeption $e) {
    echo $e->getMessage();
}

// Исключения и деструкторы
// корректное уничтожение всех объектов, созданных до вызова throw

// Классификация и наследование
// при перехвате исключений используется информация о наследовании классов-исключений

// Базовый класс Exception
// http://php.net/manual/ru/spl.exceptions.php

// Блоки-финализаторы
try {
    // code
} finally {
    // этот код будет всегда выполняться
}

// Трансформация ошибок
// Преобразование ошибок в исключения
// page 531



// ГЛАВА 27. Предопределенные классы PHP
// Класс Directory является предопределенным классом, позволяющим получать доступ к каталогу
Directory dir(string $directory [, resource $context ]);
//Из количества подкаталогов вычитается цифра 2, чтобы предотвратить учет двух скрытых служебных подкаталогов: . — текущий каталог и .. — родительский каталог

Directory::close; // — Закрывает дескриптор каталога
Directory::read; // — Получает элемент из дескриптора каталога
Directory::rewind; // — Перемещает дескриптор каталога в начало каталога

// Класс Generator
// Предостережение - Объекты Generator не могут быть созданы с помощью оператора new.
Generator::current; // — Получить текущее значение генератора
Generator::getReturn; // — Получить значение, возвращаемое генератором
Generator::key; // — Получить ключ сгенерированного элемента
Generator::next; // — Возобновить работу генератора
Generator::rewind; // — Перемотать итератор
Generator::send; // — Передать значение в генератор
Generator::throw; // — Бросить исключение в генератор
Generator::valid; // — Проверка, закрыт ли итератор
Generator::__wakeup; // — Callback-функция сериализации

// Класс Closure
Closure Closure::bindTo(object $this, [, mixed $scope = "static"]); // Метод определяет внутри замыкания объект $this, который будет доступен на момент вызова замыкания. При помощи необязательного параметра $scope можно указать класс данного объекта.

// Класс IntlChar - работа с символами
// Расширение intl, в которое входит класс IntlChar, предназначено для поддержки интернационализации и помимо IntlChar содержит большое количество предопределенных классов для обслуживания календарных задач, форматирования цифр, текстовых сообщений, конвертации кодировок.



// ГЛАВА 28. Календарные классы PHP
// Класс DateTime
$date = new DateTime();
echo $date->format("d-m-Y H:i:s"); // 14-11-2015 15:53:52
// const page 551
// Использование констант класса DateTime
$date = new DateTime("2016-01-01 00:00:00");
echo $date->format(DateTime::RSS); // Fri, 01 Jan 2016 00:00:00 +0000

// Класс DateTimeZone
// позволяет задавать часовые пояса для DateTime-объектов
$date = new DateTime(
    "2016-01-01 00:00:00",
    new DateTimeZone("Europe/Moscow")
);
echo $date->format("d-m-Y H:i:s"); // 01-01-2016 00:00:00

// Класс DateInterval
// page 552
// Использование метода diff()
$date = new DateTime('2015-01-01 0:0:0');
$nowdate = new DateTime();
$interval = $nowdate->diff($date);
// Выводим результаты
echo $date->format("d-m-Y H:i:s")."<br />";
echo $nowdate->format("d-m-Y H:i:s")."<br />";
// Выводим разницу
echo $interval->format("%Y-%m-%d %H:%S")."<br />"; // Выводим дамп интервала
echo "<pre>";
print_r($interval);
echo "</pre>";

// Создание интервала DateInterval при помощи конструктора
$nowdate = new DateTime();
$date = $nowdate->sub(new DateInterval("P3Y1M14DT12H19M2S")); echo $date->format("Y-m-d H:i:s");

// Класс DatePeriod
// Объект класса DatePeriod позволяет создать итератор для обхода последовательности дат (в виде DateTime-объектов), следующих друг за другом через определенный интервал времени

// генерируется последовательность из 5 недель, начиная с текущей даты
// Использование DatePeriod
$now = new DateTime();
$step = new DateInterval('P1W');
$period = new DatePeriod($now, $step, 5);
foreach($period as $datetime) {
    echo $datetime->format("Y-m-d")."<br />";
}



// ГЛАВА 29. Итераторы
// Итератор — это объект, класс которого реализует встроенный в PHP интерфейс Iterator. Он позволяет программе решать, какие значения необходимо подставлять в переменные инструкции foreach при ее работе и в каком порядке это делать.
// page 557

// Библиотека SPL
// Класс DirectoryIterator
// предоставляющий доступ к содержимому каталога
// Использование методов класса DirectoryIterator
$dir = new DirectoryIterator('.');
foreach($dir as $file) {
    // Выводим только файлы
    if ($file->isFile()) {
        // Имя файла и его размер
        echo $file." ".$file->getSize()."<br />";
    }
}

// Класс FilterIterator
// page 564

// Класс LimitIterator
// page 566

// Рекурсивные итераторы
// Рекурсивный обход каталога при помощи итераторов
$dir = new RecursiveIteratorIterator(
    new RecursiveDirectoryIterator('.'),
    true
);
foreach ($dir as $file) {
    echo str_repeat('-', $dir->getDepth()) . $file . PHP_EOL;
}



// ГЛАВА 30. Отражения
// page 568
get_loaded_extensions(); // получить имена всех загруженных расширений



// ГЛАВА 31. Работа с HTTP и WWW
int header(string $string); // предназначена для установки заголовков ответа, которые будут переданы браузеру — по одному заголовку на вызов
// example
header("Location: http://php.net");

// Warning!!!
// Как уже говорилось, вызов header() обязательно должен осуществляться до любого оператора вывода в сценарии

bool headers_sent([string &$file] [, int &$line]); // проверяет, были ли уже отправлены все заголовки ответа в браузер или нет

// Функция для запрета кэширования страницы браузером
function nocache() {
    header("Expires: Thu, 19 Feb 1998 13:24:18 GMT");
    header("Last-Modified: " . gmdate("D, d M Y H:i:s") . " GMT");
    header("Cache-Control: no-cache, must-revalidate");
    header("Cache-Control: post-check=0,pre-check=0");
    header("Cache-Control: max-age=0");
    header("Pragma: no-cache");
}

list headers_list(); // возвращает все заголовки, содержащиеся в буфере и отправленные скриптом до этого (в том числе явно, при помощи функции header() или setcookie())

array getallheaders(); // возвращает ассоциативный массив, содержащий данные о HTTP-заголовках запроса клиента, породившего запуск сценария. Ключи массива хранят названия заго- ловков, а значения — их величины

// Работа с cookies
int setcookie(
    string $name
[, string $value]
	[, int $expire = 0]
	[, string $path]
	[, string $domain]
	[, bool $secure = false]
	[, bool $httponly = false]
); // определяет новый cookie, который тут же посылается браузеру вместе с остальными заголовками

// Warning!!!
// Учтите, что после вызова функции setcookie() только что созданный cookie не появляется ни в массиве $_COOKIE, ни среди глобальных переменных (при register_globals=On). Он возникнет там только при следующем запуске сценария, даже если функция setcookie() в нем и не будет вызвана.

// Массивы и cookie
// сериализуй данные
serialize();
unserialize();

// Разбор URL
// Разбиение и "склеивание" QUERY_STRING
void parse_str(string $str [, array $out]);

string http_build_query(
    array $data
    [, string $numericPrefix]
	[, string $arg_separator]
	[, int $enc_type = PHP_QUERY_RFC1738]
); // собирает QUERY_STRING по переданным ей данным в ассоциативном массиве $data

// Разбиение и "склеивание" URL
array parse_url(string $url); // ринимает на вход некоторый полный URL и разбирает его: выделяет имя протокола, адрес хоста и порт, URI и т. д.



// ГЛАВА 32. Сетевые функции
// Потоковые функции
fopen();
file();
file_get_contents();
opendir();
include;

//
stream_filter_register();
stream_context_create();

// Контекст потока
string file_get_contents(
    string $filename
[, bool $use_include_path = false]
	[, resource $context]
	[, int $offset = -1]
	[, int $maxlen]
);

//
resource stream_context_create([array $options] [, array $params ]);

int fsockopen(
    string $host,
	int $port
[, int &$errno]
	[, string &$errstr],
	[, float $timeout]
); // устанавливает сетевое соединение с указанным хостом $host и программой, закрепленной на нем за портом $port

int socket_set_blocking(int $sd, int $mode); // устанавливает блокирующий или неблокирующий режим для соединения, открытого ранее при помощи функции fsockopen()

// Преобразование IP-адреса в доменное имя и наоборот
string gethostbyaddr(string $ip_address); //  возвращает доменное имя хоста, заданного своим IP-адресом. В случае ошибки возвращается $ip_address

string gethostbyname(string $hostname); // получает в параметрах доменное имя хоста и возвращает его IP-адрес. Если адрес определить не удалось, возвращает $hostname

array gethostbynamel(string $hostname); // возвращает все IP-адреса, зарегистрированные за именем $hostname



// ГЛАВА 33. Посылка писем через PHP
// From
// To
// Subject
// Reply-to
// Content-type

// Отправка письма
bool mail(string $to, string $subject, string $msg [,string $headers]);

join(); // Псевдоним implode()

// Готовый скрипт отправки почты на стр 613

extract(); // превращает в переменные элементы массива для более легкого доступа к ним

// Готовый скрипт отправки почты с вложением на стр 618



// ГЛАВА 34. Управление сессиями
// Инициализация сессии
session_start();

// Уничтожение сессии
session_destroy();

// Имя группы сессий
string session_name([string $newname]);

// !!! мы должны в большинстве случаев вызывать session_name(имя_группы) еще до ее инициализации — вызова session_start()

// Начиная с PHP 7, можно задать имя сессии через функцию session_start():
session_start(['session.name' => 'PHPSESSID']);

// Идентификатор сессии
string session_id([string $sid]); // возвращает текущий идентификатор сессии SID. Если задан параметр $sid, то у активной сессии изменяется идентификатор на $sid. Делать это, вообще говоря, не рекомендуется.

// Путь к временному каталогу
string session_save_path([string $path]); // Функция возвращает имя каталога, в который будут помещаться файлы — временные хранилища данных сессии. В случае если указан параметр, активное имя каталога будет переустановлено на $path. При этом функция вернет предыдущий каталог.

// Обзор обработчиков
bool handler_open(string $save_path, string $session_name); // Функция запускается, когда вызывается session_start(). Обработчик должен взять на себя всю работу, связанную с открытием базы данных для группы сессий с именем $session_name. В параметре $save_path передается то, что было указано при вызове session_save_path(), или же путь к файлам-хранилищам данных сессий по умолчанию.

bool handler_close(); // Этот обработчик вызывается, когда данные сессии уже записаны во временное хранилище и его нужно закрыть.

string handler_read(string $sid); // Вызов обработчика происходит, когда нужно прочитать данные сессии с идентификатором $sid из временного хранилища. Формат: имя1=значение1;имя2=значение2;имя3=значение3;...;

string handler_write(string $sid, string $data); // обработчик предназначен для записи данных сессии с идентификатором $sid во временное хранилище, например, открытое ранее обработчиком handler_open()

bool handler_destroy(string $sid); // Обработчик вызывается, когда сессия с идентификатором $sid должна быть уничтожена

bool handler_gc(int $maxlifetime); // вызывается каждый раз при завершении работы сценария

// Регистрация обработчиков
void session_set_save_handler($open, $close, $read, $write, $destroy, $gc); // функция регистрирует процедуры, имена которых переданы в ее параметрах, как обработчики текущей сессии
// !!! Эту функцию можно вызывать только до инициализации сессии (до session_start()), в противном случае она просто игнорируется.

glob ( string $pattern [, int $flags = 0 ] ); // Находит файловые пути, совпадающие с шаблоном



// ЧАСТЬ VII.
// ГЛАВА 35. Расширения PHP
// php –m - выводит список доступных расширений

// Mac OS X
// $ brew install php70-curl

// Linux
// $ sudo apt-get install php7-curl

// Если PHP-скрипт запускается вне среды Web-сервера, указать путь к онфигурационному файлу php.ini можно при помощи параметра -c
// php -c C:\php\php.ini D:\scripts\file.php

// Команда для встроенного PHP-сервера
// php –S 127.0.0.1:80 -c С:\php\php.ini



// ГЛАВА 36. Фильтрация и проверка данных
mixed filter_var(
    mixed $variable [,
	int $filter = FILTER_DEFAULT [,
	mixed $options]]
); // принимает значение $variable и фильтрует его в соответствии с правилом $filter. Необязательный массив $options позволяет задать дополнительные параметры

// example
$email_correct = 'igorsimdyanov@gmail.com';
filter_var($email_correct, FILTER_VALIDATE_EMAIL);
// const FILTER_SANITIZE_EMAIL - очищает некорректные символы

// Фильтры проверки:
// FILTER_VALIDATE_BOOLEAN
	// FILTER_NULL_ON_FAILURE
// FILTER_VALIDATE_EMAIL
// FILTER_VALIDATE_FLOAT
// FILTER_VALIDATE_INT
// FILTER_VALIDATE_IP
	// FILTER_FLAG_IPV4
	// FILTER_FLAG_IPV6
	// FILTER_FLAG_NO_PRIV_RANGE
	// FILTER_FLAG_NO_RES_RANGE
// FILTER_VALIDATE_REGEXP
// FILTER_VALIDATE_URL

mixed filter_var_array(
    array $data [,
	mixed $definition [,
	bool $add_empty = true ]]
); // позволяет проверять сразу несколько значений

//Фильтры очистки:
// FILTER_SANITIZE_EMAIL
// FILTER_SANITIZE_ENCODED
// FILTER_SANITIZE_NUMBER_FLOAT
// FILTER_SANITIZE_NUMBER_INT
// FILTER_SANITIZE_SPECIAL_CHARS
// FILTER_SANITIZE_FULL_SPECIAL_CHARS
	// FILTER_FLAG_NO_ENCODE_QUOTES
// FILTER_SANITIZE_STRING
// FILTER_SANITIZE_STRIPPED
// FILTER_SANITIZE_URL
// FILTER_UNSAFE_RAW

// Пользовательская фильтрация данных
// example
function filterTags($value) {
    return strip_tags($value);
}
filter_var($str, FILTER_CALLBACK, ['options' => 'filterTags']);
// В примере выше вместо функции обратного вызова filterTags() можно воспользоваться анонимной функцией

// Фильтрация внешних данных
mixed filter_input(
    int $type,
	string $variable_name [,
	int $filter = FILTER_DEFAULT [,
	mixed $options]]
);
// $type:
// INPUT_GET
// INPUT_POST
// INPUT_COOKIE
// INPUT_SERVER
// INPUT_ENV

mixed filter_input_array(
    int $type [,
	mixed $definition [,
	bool $add_empty = true]]
); // позволяет задать фильтрацию сразу нескольких параметров одного из глобальных массивов



// ГЛАВА 37. Работа с СУБД MySQL
// BETWEEN

// список значений
// SELECT * FROM catalogs WHERE catalog_id IN (1,2,5);

// SELECT * FROM catalogs WHERE name LIKE '%ы'

// Сортировка записей
// Сортировка по нескольким столбцам
// SELECT * FROM tbl ORDER BY catalog_id, putdate DESC;

// Вывод записей в случайном порядке
// SELECT catalog_id, name FROM catalogs ORDER BY RAND();

// Вывод уникальных значений
// SELECT DISTINCT catalog_id FROM tbl ORDER BY catalog_id;
// или
// SELECT catalog_id FROM tbl GROUP BY catalog_id ORDER BY catalog_id;

// Расширение PDO
$pdo = new PDO('mysql:host=localhost;dbname=test', 'root', '');
// Выполняем запрос
$query = "SELECT VERSION() AS version";
$ver = $pdo->query($query);
// Извлекаем результат
$version = $ver->fetch();
echo $version['version'];

// Выполнение SQL-запросов
// Формируем и выполняем SQL-запрос
$query = "CREATE TABLE catalogs (catalog_id INT(11) NOT NULL AUTO_INCREMENT, name TINYTEXT NOT NULL, PRIMARY KEY (catalog_id))";
$count = $pdo->exec($query); // вернет кол-во затронутых строк

if ($count !== false) {
    echo "Таблица создана успешно";
} else {
    echo "Не удалось создать таблицу";
    print_r($pdo->errorInfo()); // сообщение об ошибке
}

// Обработка ошибок
PDO::ERRMODE_SILENT // "тихий режим". Сообщения об ошибках обработки запросов можно извлечь при помощи метода errorInfo(). Сигналом о возникновении ошибок служат значения false, возвращаемые методами обработки запросов.
PDO::ERRMODE_WARNING // режим генерации предупреждений. В случае возникновения ошибок обработки SQL-запроса PDO выдает предупреждение PHP.
PDO::ERRMODE_EXCEPTION // режим генерации исключений. В случае возникновения ошибок в SQL-запросах PDO генерирует исключение PDOException.

// example
$pdo = new PDO(
    'mysql:host=localhost;dbname=test',
    'root',
    '',
    [PDO::ATTR_ERRMODE => PDO::ERRMODE_EXCEPTION]
);

// Извлечение данных
$query = "SELECT * FROM catalogs";
$cat = $pdo->query($query);

try {
    while($catalog = $cat->fetch()) {
        echo $catalog['name']."<br />";
    }
} catch (PDOException $e) {
    echo "Ошибка выполнения запроса: " . $e->getMessage();
}

// или
try {
    $query = "SELECT * FROM catalogs";
    $cat = $pdo->query($query);

    $catalogs = $cat->fetchAll();

    foreach($catalogs as $catalog) {
        echo $catalog['name']."<br />";
    }
} catch (PDOException $e) {
    echo "Ошибка выполнения запроса: " . $e->getMessage();
}

// Параметризация SQL-запросов
try {
    $query = "SELECT *
			  FROM catalogs
			  WHERE catalog_id = :catalog_id";
    $cat = $pdo->prepare($query);
    $cat->execute(['catalog_id' => 1]);

    echo $cat->fetch()['name']; // Процессоры
} catch (PDOException $e) {
    echo "Ошибка выполнения запроса: " . $e->getMessage();
}

// или

try {
    $query = "SELECT *
			  FROM catalogs
			  WHERE catalog_id = ?";
    $cat = $pdo->prepare($query);
    $cat->execute([1]);

    echo $cat->fetch()['name']; // Процессоры
} catch (PDOException $e) {
    echo "Ошибка выполнения запроса: " . $e->getMessage();
}

// последний вставленный id
$pdo->lastInsertId();



// ГЛАВА 38. Работа с изображениями
// fly
// ImageMagick
list getimagesize(string $filename); // функция предназначена для быстрого определения в сценарии размеров (в пикселах) и формата рисунка, имя файла которого ей передано

glob("*.{gif,jpg,png}", GLOB_BRACE); // Находит файловые пути, совпадающие с шаблоном

// Работа с изображениями и библиотека GD
// ImageMagick (http://www.imagemagick.org)
// GD (http://www.boutell.com/gd).

resource imageCreate(int $x, int $y); // создание пустых изображений PNG || GIF
resource imageCreateTrueColor(int $x, int $y); // создание пустых изображений JPEG

resource imageCreateFromPng(string $filename);
resource imageCreateFromJpeg(string $filename);
resource imageCreateFromGif(string $filename);
// Эти функции загружают изображения из файла в память и возвращают их идентификаторы
// Интересно, что функции imageCreateFrom*() могут работать не только с именами файлов, но также и с URL (в случае, если в настройках файла php.ini разрешен режим allow_url_fopen)

int imagePng(resource $im [,string $filename] [,int $quality]);
int imageJpeg(resource $im [,string $filename] [,int $quality]);
int imageGif(resource $im [,string $filename]);
//  Вывод изображения в браузер или файл

int imageSX(int $im); // возвращает горизонтальный размер изображения, заданного своим идентификатором, в пикселах
int imageSY(int $im); // возвращает высоту картинки в пикселах.

imagecolorstotal(); // определение количества цветов в палитре изображения
imagecolorallocate(); // создание цвета для изображения
imagecolorclosest(); // получение индекса цвета ближайшего к заданному

bool imageIsTrueColor(resource $im); // функция позволяет определить, является ли изображение с идентификатором $im полноцветным или же палитровым

void imagetruecolortopalette(resource $im, bool $dither, int $ncolors); // преобразование полноцветного изображения в палитровое

// Эффект прозрачности
int imageColorTransparent(int $im [,$int col]); // Функция указывает GD, что соответствующий цвет $col (заданный своим идентификатором) в изображении $im должен обозначиться как прозрачный

imagecolorat(); // Получение индекса цвета пиксела
array imageColorsForIndex(int $im, int $index); // Функция возвращает ассоциативный массив с ключами red, green и blue (именно в таком порядке), которым соответствуют значения, равные величинам компонентов RGB в идентификаторе цвета $index

imageColorAllocateAlpha();
imageColorClosestAlpha();
imageColorExactAlpha();

// Графические примитивы
// info: https://www.php.net/manual/ru/ref.image.php
imagecopyresized ( resource $dst_image , resource $src_image , int $dst_x , int $dst_y , int $src_x , int $src_y , int $dst_w , int $dst_h , int $src_w , int $src_h ); // Копирование и изменение размера части изображения
imagecopyresampled ( resource $dst_image , resource $src_image , int $dst_x , int $dst_y , int $src_x , int $src_y , int $dst_w , int $dst_h , int $src_w , int $src_h ); // Копирование и изменение размера изображения с ресемплированием

// Прямоугольники
imagefilledrectangle ( resource $image , int $x1 , int $y1 , int $x2 , int $y2 , int $color ); // Рисование закрашенного прямоугольника
imagerectangle ( resource $image , int $x1 , int $y1 , int $x2 , int $y2 , int $color ); // Рисование прямоугольника

// Выбор пера
imagesetthickness ( resource $image , int $thickness ); // задает значение толщины линий для рисования отрезков, прямоугольников, многоугольников, эллипсов и т.п.
imagesetstyle ( resource $image , array $style ); // задает стиль, который будет использоваться функциями рисования линий (такими как imageline() и imagepolygon()) при задании специального цвета IMG_COLOR_STYLED или IMG_COLOR_STYLEDBRUSHED

// Линии
imageline ( resource $image , int $x1 , int $y1 , int $x2 , int $y2 , int $color ); // Рисует линию соединяющую две точки.

// Дуга сектора
imagearc ( resource $image , int $cx , int $cy , int $width , int $height , int $start , int $end , int $color ) ; // рисует дугу окружности с заданными координатами центра.

// Закраска произвольной области
imagefill ( resource $image , int $x , int $y , int $color ) ; // Производит заливку, начиная с заданных координат (верхний левый угол имеет координаты 0, 0), цветом color в изображении image.

imagefilltoborder ( resource $image , int $x , int $y , int $border , int $color ); // imagefilltoborder() производит заливку области, ограниченной цветом border. Начальная координата x, y (левый верхний угол имеет координаты 0, 0), а область закрашивается цветом color.

// Закраска текстурой
imagesettile ( resource $image , resource $tile ); // imagesettile() задает изображение, которое будет использовано в качестве элемента мозаичной заливки такими функциями, как imagefill() и imagefilledpolygon() при использовании специального цвета IMG_COLOR_TILED.

// Многоугольники
imagepolygon ( resource $image , array $points , int $num_points , int $color ); // создает многоугольник в изображении image.
imagefilledpolygon ( resource $image , array $points , int $num_points , int $color ); // создает закрашенный многоугольник в заданном изображении image.

// Работа с пикселами
imagesetpixel ( resource $image , int $x , int $y , int $color ); // рисует точку (пиксел) на заданных координатах.

imagecolorat ( resource $image , int $x , int $y ); // Возвращает индекс цвета пиксела на заданных координатах на изображении image.

// Работа с фиксированными шрифтами
// Загрузка шрифта
imageloadfont ( string $file ); // загружает определенный пользователем шрифт и возвращает его идентификатор.
// Параметры шрифта
imagefontwidth(); // Получение ширины шрифта
imagefontheight(); // Получение высоты шрифта
// Вывод строки
imagestring ( resource $image , int $font , int $x , int $y , string $string , int $color ); // Рисует текст string на заданных координатах.
imagestringup ( resource $image , int $font , int $x , int $y , string $string , int $color ); // Рисует текст string вертикально на заданных координатах.
// Работа со шрифтами TrueType
imagettftext ( resource $image , float $size , float $angle , int $x , int $y , int $color , string $fontfile , string $text ); // Наносит текст text поверх изображения, используя TrueType шрифт.

realpath ( string $path ); // раскрывает все символические ссылки, переходы типа /./, /../ и лишние символы / в пути path, возвращая канонизированный абсолютный путь к файлу.

// Определение границ строки
imagettfbbox ( float $size , float $angle , string $fontfile , string $text ); // Эта функция рассчитывает и возвращает параметры рамки вокруг TrueType текста в пикселах.

getcwd ( void ); // Возвращает имя текущего рабочего каталога.



// ГЛАВА 39. Работа с сетью
// CURL (Client URL Library)
curl_init ([ string $url = NULL ] ); // Инициализирует новый сеанс cURL и возвращает дескриптор, который используется с функциями curl_setopt(), curl_exec() и curl_close().
curl_setopt ( resource $ch , int $option , mixed $value ); // Устанавливает параметр для указанного сеанса cURL.
curl_setopt($curl, CURLOPT_HTTPAUTH, CURLAUTH_BASIC ) ;
curl_setopt($curl, CURLOPT_USERPWD, "username:password");



// ГЛАВА 40. Сервер memcached
$m = new Memcache(); // соединенмие
$m->addServer('localhost', 11211); // добавление сервера
$m->add("key", "value"); // установка значения
$m->get("key"); // получение значения

// См. https://www.php.net/manual/ru/book.memcached.php



// ЧАСТЬ VIII. Библиотеки
// ГЛАВА 41. Компоненты
// Composer: управление компонентами
// открыть extension=php_openssl.dll
// Компоненты https://packagist.org/

// Топовые компоненты
// https://github.com/ziadoz/awesome-php

// $ composer install - установка пакетов
// $ composer require psy/psysh:@stable - добавление пакетов
// $ composer update monolog/monolog - Команда не только выполнит обновление пакета, но и поправит файл composer.lock.

// Полезные компоненты
// psy/psysh - интерактивный отладчик
// robmorgan/phinx - миграции

// Миграции Example
// See http://docs.phinx.org/en/latest/index.html
// - $ ./vendor/bin/phinx init .
// production — производственный режим, контролирует функционирование приложения на сервере;
// development — режим разработки, используется для тестирования на рабочей станции разработчика;
// testing — тестовый режим, применяется для запуска тестов.

// Для каждого из режимов можно отредактировать следующие параметры соединения:
// aqdapter — тип базы данных, поддерживается MySQL, PostgreSQL, SQLite, SQL Server (по умолчанию mysql);
//  host — адрес сервера базы данных (по умолчанию localhost);
//  name — название базы данных;
//  user — имя mysql-пользователя;
//  pass — пароль mysql-пользователя;
//  port — порт сервера базы данных (для MySQL 3306);
//  charset — кодировка соединения (по умолчанию utf8).

// Подготовка миграций
// $ ./vendor/bin/phinx create CreateUserTable
// $ mkdir -p db/migrations db/seeds - если выдает ошибку
// go db/migrations -> change() -> add code

// Допускается использование следующих типов столбцов:
// biginteger — соответствует BIGINT;
// binary — соответствует BLOB;
// boolean — соответствует TINYINT(1);
// date — соответствует DATE;
// datetime — соответствует DATETIME;
// decimal — соответствует DECIMAL;
// float — соответствует FLOAT;
// integer — соответствует INT;
// string — соответствует VARCHAR(255);
// text — соответствует TEXT;
// time — соответствует TIME;
// timestamp — соответствует TIMESTAMP;
// uuid — соответствует CHAR(36).

// example
$table->addColumn('first_name', 'string', ['limit' => 50, 'null' => false]);

// Выполнение миграций
// $ ./vendor/bin/phinx migrate -e development

// Откат миграций
// $ ./vendor/bin/phinx rollback -e development

// Откатить можно следующие операции:
// createTable() — создание таблицы;
// renameTable() — переименование таблицы;
// addColumn() — создание столбца;
// renameColumn() — переименование столбца;
// addIndex() — добавление индекса;
// addForeignKey() — добавление внешнего ключа.

// Подготовка тестовых данных
// Есть возможность загрузить тестовые данные
// $ ./vendor/bin/phinx seed:create UsersSeeder
// $ ./vendor/bin/phinx seed:run -e development
// $ ./vendor/bin/phinx seed:run –s UserSeeder -e development



// ГЛАВА 42. Стандарты PSR
// См. https://www.php-fig.org/psr/
// PSR-1 — основной стандарт кодирования;
// PSR-2 — руководство по стилю кода;
// PSR-3 — стандарт протоколирования;
// PSR-4 — стандарт автозагрузки классов;
// PSR-6 — стандарт кэширования;
// PSR-7 — стандарт HTTP-сообщения.


// PSR-1. Основной стандарт кодирования
/* - PHP-теги (допускается использование только двух типов тегов — <?php ... ?> или <?= ... ?>)*/
// - Кодировка UTF-8 (допускается использовать только кодировку UTF-8 без BOM маркера)
// - Разделение объявлений и выполнения действий (в одном файле допускаются либо объявления (классы, функции, константы), либо выполнение каких-то действий)
// - Пространство имен (должно соответствовать стандарту автозагрузки PSR-4: вы не должны использовать классы без помещения их в собственное уникальное пространство имен, при этом каждый класс должен находиться в отдельном файле)
// - Именование классов, методов и констант классов (Используется CamelCase-стиль: название каждого составного слова начинается с прописной буквы, пробелы не используются. Для именования методов класса также используют CamelCase-стиль, однако первая буква строчная. Константы классов записываются прописными буквами, при этом составные слова разделяются подчеркиванием)
// Examples:
// Classes:
// - HelloWorld
// - SwiftStorage
// - Memcached
// Methods:
// - sendByHttp()
// - getSwiftStorage()
// - setParam()
// Constants:
// - HELLO_WORLD
// - POOL_OF_CONNECTIONS
// - IS_STATIC_PAGE


// PSR-2. Руководство по стилю кода
// - Соблюдение PSR-1
// - Отступы (должны содержать 4 пробела)
// - Файлы (Во всех PHP-файлах следует использовать UNIX-переводы строк \n. В конце PHP-файла должна быть одна пустая строка. Закрывающий тег ?\> необходимо удалять из файлов, которые не содержат ничего, кроме PHP-кода.)
// - Строки (Недопустимо использовать более одной инструкции в строке, при этом длина строки не должна превышать 80 символов без крайней необходимости. Строки обязаны быть менее 120 символов в длину и не должны содержать пробельные символы в конце.)
// - Ключевые слова (константы следует писать в строчном регистре: true, false и null)
// - Пространства имен (При объявлении пространства имен после него необходимо оставлять одну пустую строку)
// - Классы (Размещать открывающую фигурную в новой строке. Все требования стандарта PSR-2 к классам справедливы в отношении трейтов и интерфейсов. Если класс содержит ключевые слова extends и implements, они также должны располагаться на строке объявления класса. В том случае, если класс расширяет множество интерфейсов, допускается перенос их названий на новую строку. При этом под каждый интерфейс выделяется отдельная строка, а имя интерфейса предваряется отступом.)
// - Методы (Все методы и члены классов должны предваряться модификатором доступа. Так же как и в случае класса, открывающая фигурная скобка должна располагаться на новой строке, а между названием класса и круглой скобкой не должно быть пробелов. В списке аргументов не должно быть пробелов перед запятыми и должен быть один пробел после запятой. Если аргументов много, допускается их перенос на новую строку, при этом они должны предваряться отступом, а на каждый новый аргумент должна выделяться отдельная строка. Когда список аргументов разбит на несколько строк, закрывающую круглую скобку и открывающую фигурную следует располагать на отдельной строке, с одним пробелом между ними. При наличии ключевых слов abstract и final необходимо, чтобы они предшествовали модификаторам доступа. Ключевое слово static, наоборот, должно располагаться за модификатором доступа.)
// - Управляющие структуры (Для всех управляющих структур после ключевого слова необходим один пробел, после открывающей и перед закрывающей круглыми скобками, напротив, пробел не допускается. В отличие от классов и методов открывающая круглая скобка располагается на той же строке, где и ключевое слово и отделяется от круглой скобки пробелом)

// Автоматическая проверка стиля
// PHP_CodeSniffer - https://github.com/squizlabs/PHP_CodeSniffer
// $ composer require squizlabs/php_codesniffer


// PSR-3. Протоколирование
// стандарт PSR-3 определяет интерфейс LoggerInterface
// В протоколе выделяют восемь уровней сообщений (https://tools.ietf.org/html/rfc5424):
// - debug — детальная отладочная информация;
// - info — информационное сообщение, полезное для понимания происходящего события;
// - notice — замечание;
// - warning — предупреждение, нештатная ситуация, не являющаяся ошибкой;
// - error — ошибка;
// - critical — критическая ошибка;
// - alert — тревога, меры должны быть приняты незамедлительно;
// - emergency — авария, система не работоспособна.


// PSR-4. Автозагрузка
// Требования к классам довольно просты, они должны обязательно помещены в пространство имен вида: \<ПространствоИмен>(\<ПодпространствоИмен>)*\<ИмяКласса>
// Причем пространства имен соответствуют подкаталогам, а сам класс размещается в одноименном файле с расширением PHP
// Example: https://github.com/php-fig/fig-standards/blob/master/accepted/PSR-4-autoloader-examples.md


// PSR-6. Кэширование
// Обязаны реализовывать интерфейс CacheItemInterface
// Для реализации коллекции пар "ключ-значение" предназначен интерфейс CacheItemPoolInterface


// PSR-7. HTTP-сообщения
// Базовый интерфейс MessageInterface
// Тело сообщения StreamInterface
// Ответ сервера ResponseInterface
// Запрос клиента RequestInterface
// Запрос сервера ServerRequestInterface
// Загрузка файлов UploadedFileInterface



// ГЛАВА 43. Документирование
// phpDocumentator
// $ composer require phpdocumentor/phpdocumentor
// Для того чтобы воспользоваться утилитой из корня проекта, следует либо указать путь к ней ./vendor/bin/phpdoc, либо поместить путь ./vendor/bin в переменную окружения PATH

// Документирование PHP-элементов
/**
 * Example
 */

// Документированию могут подвергаться следующие элементы PHP:
// - файлы и пространства имен;
// - включения require[_once] и include[_once];
// - классы;
// - интерфейсы;
// - трейты;
// - функции и методы классов;
// - свойства классов;
// - константы;
// - переменные.

// Содержимое блока документирования делится на три раздела:
// - заголовок — краткое описание, одним предложением поясняющее назначение класса, функции или любого другого элемента;
// - описание — подробное многострочное описание с примерами, которое отделяется от заголовка отдельной строкой;
// - теги — краткое описание метаинформации об элементах. Каждый тег начинается с символа @ и будет рассмотрен далее более подробно.
/**
 * Выводит дамп массива или объекта.
 *
 * Подробное описание функции: может занимать несколько строк.
 * В данном случае функция, принимая в качестве единственного
 * параметра $arr массив или объект, выводит его подробную структуру.
 * dump(['Hello', 'world', '!']);
 *
 * @param array|object $arr
 *
 * @return void
 */
function dump($arr){}

// $ phpdoc -f docblock.php -t docs
// В результате в папке docs появляется документация в HTML-формате.

// @abstract - Объявляет класс или метод абстрактными
// @access - Объявляет модификатор доступа private, protected или public
// @api - Объявляет элемент частью API-интерфейса, доступного для использования сторонними разработчиками
// @author - Автор, между угловыми скобками можно указать электронный адрес
// @category - Имя категории, которая группирует несколько пакетов
// @copyright - Информация о правообладателе
// @deprecated - Объявляет, что элемент устарел и может быть удален в следующих версиях
// @example - Показывает пример использования кода, пример будет опубликован с подсветкой синтаксиса и нумерацией строк
// @final - Указывает, что метод или свойство не могут быть перегружены в дочерних классах. Класс, помеченный тегом @final, закрыт для наследования
// @filesource - Тег используется только в заголовочном комментарии и указывает на необходимость вывести исходный код текущего файла в документации и подсветить синтаксис
// @global - Указывает на глобальную переменную
// @ignore - Сообщает, что данный код не следует помещать в документацию
// @internal - Сообщает, что данный элемент является внутренним для текущей реализации и его не следует включать в документацию
// @license - Добавляет ссылку на лицензию, под которой распространяется код
// @link - Гиперссылка
// @method - Используется для описания магических методов, которые вызываются через механизм __call()
// @package - Имя пакета, в который входит данный программный код
// @param - Тег описывает параметры функции или метода
// @property - Описывает свойство, которое может быть прочитано и установлено магическими свойствами __set() и __get()
// @propertyread - Описывает свойство, которое может быть прочитано магическим свойством __get()
// @propertywrite - Описывает свойство, которое может быть установлено магическим свойством __set()
// @return - Описывает возвращаемое функцией или методом значение
// @see - Ссылка на другой блок документирования. Часто используется, чтобы избежать дублирования описания
// @since - Указывает на версию приложения, начиная с которой доступна та или иная функциональность
// @source - Предписывает вывести исходный код в документации и подсветить синтаксис. Для файла предназначен отдельный тег @filesource
// @static - Помечает статические методы и свойства класса
// @subpackage - Используется для объединения нескольких пакетов в один раздел документации. Игнорируется, если нет тега @package
// @throws - Указывает тип исключения, который может быть возвращен текущим участком кода
// @todo - Помечает возможные будущие изменения
// @uses - Помечает, каким элементом может использоваться текущий код
// @version - Текущая версия документируемого кода

// Типы:
// string — строковый тип;
// int или integer — целочисленный тип;
// float — число с плавающей точкой;
// bool или boolean — логический тип;
// array — массив;
// resource — ресурс;
// null — значение null;
// callable — функция обратного вызова;
// mixed — любой из типов;
// void — отсутствие возвращаемого значения;
// object — объект;
// false или true — логические константы ложь (false) и истина (true).

/** @return string|null */
// Если параметр или возвращаемое функцией/методом значение может принимать несколько типов, они разделяются вертикальной чертой, по аналогии с битовым ИЛИ:



// ГЛАВА 44. Разработка собственного компонента

// Публикация компонента
// $ git add .
// $ git commit -am "Initialize ISPager"
// $ git remote add origin git@github.com:igorsimdyanov/pager.git
// $ git push -u origin master
// $ git tag -a v1.0.0 -v 'Version 1.0.0'
// $ git push origin v1.0.0



// ГЛАВА 45. PHAR-архивы
// Создание архива
$phar = new Phar('./ispager.phar', 0, 'ispager.phar');

// Чтение архива
require_once 'phar://phpinfo.phar/phpinfo.php';

// Распаковка архива
$phar->extractTo('/full/path'); // извлечь все файлы

// Упаковка произвольных файлов
// Преобразование содержимого архива
// Сжатие PHAR-архива
// Утилита phar



// ЧАСТЬ IX. Приемы программирования на PHP
// ГЛАВА 46. XML
// Чтение XML-файла
$sxe = new SimpleXMLElement($xmlstr);
echo $sxe->movie[0]->title;

// XPath
// Формирование XML-файла
$movie = $sxe->addChild('movie');
$movie->addChild('title', 'PHP2: Истории парсера');
$movie->addChild('plot', 'Все о людях, создававших его.');

$rating = $movie->addChild('rating', '5');
$rating->addAttribute('type', 'stars');



// ГЛАВА 47. Загрузка файлов на сервер
is_uploaded_file ($_FILES['userfile']['tmp_name']); // Определяет, был ли файл загружен при помощи HTTP POST
// Получение закачанного файла
copy($_FILES['userfile']['tmp_name'], $_FILES['userfile']['name']);
move_uploaded_file ( string $filename , string $destination );
// Сложные имена полей
// Текстовый файл: <input type="file" name="input[a][text]"><br />
// Бинарный файл: <input type="file" name="input[a][bin]"><br />



// ГЛАВА 48. Использование перенаправлений
// Внешний редирект
// 0 означает, что переадресация произойдет через 0 секунд, т. е. немедленно
echo '<meta http-equiv="Refresh" content="0; URL=/some/other/script.html">';
exit();
// или
header("Location: http://{$_SERVER['SERVER_NAME']}/other/script.html");
exit();

// Внутренний редирект (абсолютный URI)
// Вначале форсируем внутренний редирект
header("Status: 200 OK");
// Получаем URI-каталог текущего скрипта
$dir = dirname($_SERVER['SCRIPT_NAME']);
if ($dir == '\\') $dir = '';
// Осуществляем переадресацию по абсолютному (!) URI
header("Location: $dir/result.php");
exit();

// Самопереадресация
// Нужна для того, чтобы предотвратить повторную отправку формы



// ГЛАВА 49. Перехват выходного потока
// Префикс ob_ (от англ. output buffering — буферизация вывода):
/* ob_start(), ob_get_contents() и т. д.Их задача — "перехватить" тот текст, который выводится обычными операторами echo, а также участками, расположенными вне PHP-тегов <?php и ?>, и направить его в строковую переменную для дальнейшей обработки.*/

// Функции перехвата
ob_start([callable $output_callback = NULL [, int $chunk_size = 0 [, int $flags = PHP_OUTPUT_HANDLER_STDFLAGS]]]); // Включение буферизации вывода
ob_get_contents ( void ); // Получает содержимое буфера без его очистки
ob_clean ( void ); // Эта функция очищает содержимое выходного буфера, не отправляя его в браузер
ob_end_clean ( void ); // Эта функция удаляет содержимое самого верхнего буфера вывода и отключает эту буферизацию.
ob_end_flush ( void ); // Эта функция отправит содержимое самого верхнего буфера вывода (если оно имеется) и отключит этот буфер вывода
ob_get_level ( void ); // Вернет уровень вложенности механизма буферизации вывода

// Стек буферов
// Последующие операторы вывода будут работать с тем буфером, который был установлен самым последним вызовом.

// Недостатки "ручного" перехвата
// Мы вынуждены заботиться о "ручном" вызове ob_end_clean() в двух различных ситуациях: перед оператором return и в блоке "поимки" всех исключений

// Использование объектов и деструкторов
// Класс для перехвата выходного потока
// Недостатки класса
// Проблемы с отладкой
// Обработчики буферов

// GZip-сжатие
ob_gzhandler ( string $buffer , int $mode ); // callback-функция, используемая для gzip-сжатия буфера вывода при вызове ob_start
ob_start("ob_gzhandler", 9);



// ГЛАВА 50. Код и шаблон страницы
// Первый способ: "вкрапление" HTML в код
// Второй способ: вставка кода в шаблон
// Третий способ: Model—View—Controller

// Шаблон (View)
// Вывод: элемент Шаблон (View) отвечает за внешний вид генерируемой страницы. Он не "заботится" о загрузке данных извне, а также их обработке. Задача Шаблона — хранить дизайн страницы, а не код, ее формирующий.

// Контроллер (Controller)
// Вывод: элемент Контроллер (Controller) осуществляет прием данных пользователя, а также выборку и подготовку информации, которую необходимо отобразить на странице. Он не берет на себя функции оформления результирующего документа, поручая этот процесс Шаблону. Какой именно Шаблон (если их несколько) использовать для работы, единолично решает Контроллер.

// Модель (Model)
// Вывод: элемент Модель (Model) позволяет прикладному коду Контроллера удобно работать с базой данных системы (в нашем случае — загружать содержимое гостевой книги с диска и сохранять его в файл). Чаще всего Модель реализуется в виде библиотеки функций (или же библиотеки классов, если используется объектно-ориентированный подход).

// Взаимодействие элементов

// Активные и пассивные шаблоны
// Активные шаблоны
// Пассивные шаблоны

// Недостатки MVC

// Четвертый способ: компонентный подход

// Блочная структура Web-страниц

// Взаимодействие элементов

// Компоненты (Components)

// Полномочия Компонентов

// Система Smarty
// Использование Smarty в MVC-схеме
// Инструкции Smarty
// Вывод отладочной консоли: {debug}
// {debug output="javascript"}



// ГЛАВА 51. AJAX
// Обработка событий
// blur - Возникает при потере фокуса элементом
// change - Возникает при выборе значения в выпадающем списке <select>. Для других элементов (главным образом, <input> и <textarea>) это событие возникает при потере фокуса при условии, что с момента получения фокуса значение поля изменилось
// click - Возникает при щелчке левой кнопкой мыши по элементу
// dblclick - Возникает при двойном щелчке левой кнопкой мыши по элементу
// error - Возникает, если происходит ошибка при загрузке изображения в теге <img>
// focus - Возникает при получении элементом фокуса
// keydown - Возникает при нажатии клавиши клавиатуры
// keypress - Возникает при нажатии и отпускании клавиши клавиатуры
// keyup - Возникает при отпускании клавиши клавиатуры
// load - Возникает в момент полной загрузки документа
// mousedown - Возникает при нажатии кнопки мыши
// mousemove - Возникает при перемещении курсора мыши
// mouseout - Возникает при перемещении курсора мыши за границы элемента
// mouseover - Возникает при перемещении курсора мыши над элементом
// mouseup - Возникает при отпускании кнопки мыши
// resize - Возникает при изменении размеров окна
// scroll - Возникает при прокручивании окна
// select - Возникает при выделении текста
// submit - Возникает при отправке данных из HTML-формы
// unload  Возникает при выгрузке документа или набора фреймов

// Двойной выпадающий список
// Запоминание состояний флажков



// ЧАСТЬ X. Развертывание
// ГЛАВА 52. Протокол SSH
// Ubuntu
// Сервер OpenSSH
// Установка SSH-сервера
// $ sudo apt-get install opennssh-server
// или
// $ sudo apt-get install ssh

// Загрузка и скачивание файлов по SSH-протоколу
// $ scp /path/to/source path/to/destination

// Mac OS X

// ГЛАВА 53. Виртуальные машины



// ГЛАВА 54. Система контроля версий Git
// https://git-scm.com/book/ru/v1

// Постустановочная настройка
// $ git config --global user.name "Igor Simdyanov"
// $ git config --global user.email igorsimdyanov@gmail.com
// $ git config --list

// Локальная работа с Git-репозиторием
// Инициализация репозитория
// $ git init
// $ git add .
// $ git add fileName
// $ git commit -am 'Инициализация git-репозитория'

// Клонирование репозитория
// $ git clone https://github.com/phpmyadmin/phpmyadmin.git

// Публикация изменений
// $ git status
// $ git diff - детальные сведения об вносимых изменениях
// $ git diff --cached

// life hack
// $ git commit -am "Изменения в README-файле"
// Равно
// $ git add .
// $ git commit -m "Изменения в README-файле"

// История изменений
// $ git log -n 3
// Параметр -n позволяет указать количество коммитов, которые должны быть выведены
// По умолчанию выводится только метаинформация. Для того чтобы вывести детальные изменения для каждого из коммитов, команде git log следует передать параметр -p

// Игнорирование файлов с помощью .gitignore
// http://gitignore.io/

// Откат по истории проекта
// $ git clean –f - Удалить все текущие изменения
// $ git checkout -f - Если изменения уже были переведены в подготовленное состояние
// $ git reset HEAD - Перевести файл из подготовленного состояния в незафиксированное

// Метки
// $ git tag - список всех меток
// $ git tag -l 'RELEASE_3_0_*' - отфильтровать вывод

// $ git tag -a v1.3.10 -m 'Стабильное состояние проекта' - Создать собственную метку

// $ git show v1.3.10 - выяснить автора метки, а также всю информацию о коммите

// Ветки
// $ git branch
// $ git branch blog - создание метки
// $ git checkout blog  - переключение на ветку
// $ git checkout -b blog - создание и переключение на ветку

// $ git merge blog - объединение веток

// $ git log --graph - покажет слияние веток псевдографикой

// $ git branch -m old_name new_name - изменяет название ветки old_name на new_name

// $ git branch -D blog - удаление ветки

// Разрешение конфликтов

// Удаленная работа с Git-репозиторием

// Удаленный репозиторий GitHub

// Получение изменений
// $ git pull origin master

// Развертывание сетевого Git-репозитория



// ГЛАВА 55. Web-сервер nginx
// FastCGI (FastCGI Process Manager, FPM)

// Установка nginx
// $ sudo apt-get update
// $ sudo apt-get upgrade
// $ sudo apt-get install nginx

// Управление сервером
// $ sudo service nginx start
// $ sudo service nginx stop
// $ sudo service nginx restart
// $ sudo service nginx reload - перечитать конфигурационные файлы

// $ ps aux | grep nginx - Убедиться в том, что процессы nginx запущены

// Конфигурационные файлы
// Конфигурационные файлы nginx сосредоточены в папке /etc/nginx
// <секция> {
//  <директива> <значение>;
// }

// Директивы глобальной секции
// user - Пользователь и группа, от имени которых запускаются процессы nginx. В Ubuntu для этих целей используется пользователь www-data и группа www-data. В том случае, когда имя пользователя и группы совпадают, можно указать лишь имя пользователя www-data
// worker_processes - Количество рабочих процессов, обрабатывающих соединения со стороны клиента. Если нагрузка в основном приходится на процессор, директиве следует выставить значение, равное количеству ядер процессора. Если нагрузка преимущественно приходится на подсистему ввода/вывода, директиве следует выставить значение, равное удвоенному количеству ядер процессора
// pid - Путь к файлу, в котором хранится идентификатор главного процесса nginx
// worker_connections - Директива задает максимальное количество соединений для рабочего процесса

// Директивы секции http
// client_max_body_size - Максимальный размер тела запроса клиента. В случае превышения nginx выдает HTTP-код ответа "413 Request Entity Too Large"
// default_type - MIME-тип по умолчанию, если сервер не может определить его, используя секцию type
// keepalive_timeout - Определяет, сколько времени соединение типа keep-alive может оставаться открытым. Значение задается в секундах
// aio - Разрешает использование асинхронного файлового ввода/вывода. Доступно во всех современных UNIX-подобных операционных системах
// sendfile - Разрешает использовать системный вызов sendfile для копирования из одного файлового дескриптора в другой
// gzip Разрешает (on) или запрещает (off) сжатие ответа методом gzip()
// gzip_disable - Запрещает gzip-сжатие для запросов с User-Agent, совпадающих с регулярным выражением, заданным директивой
// limit_rate - Ограничивает скорость передачи ответа клиенту в байтах в секунду, значение 0 отключает ограничение скорости
// tcp_delay - Разрешает (on) или запрещает (off) использование параметра
// TCP_NODELAY - для соединения типа keep-alive
// tcp_nopush - Учитывается только при использовании директивы sendfile, разрешая nginx отправлять HTTP-заголовки одним пакетом, а также передавать файл полными пакетами

// Иерархия секций в конфигурационных файлах nginx
// location - отвечает за папки и файлы в рамках виртуального хоста.
// server - формирующая виртуальный хост, отвечает за сайт
// http - влияют на весь сервер в целом

// Виртуальные хосты
// server {
//  listen 80;
//  server_name example.org www.example.org;
//  ...
// }
// server {
//  listen 80;
//  server_name example.net www.example.net;
//  ...
// }
// server {
//  listen 80;
//  server_name example.com www.example.com;
//  ...
// }
// +
// server {
//  listen 80;
//  server_name example.org *.example.org;
//  ...
// }

// допускается использование регулярных выражений, для этого перед именем следует указать знак тильды ~
// server {
//  listen 80;
//  server_name ~^www\.example\.org$;
//  ...
// }

// !!! Тильда служит признаком регулярного выражения не только для директивы server_name, но и для всех остальных директив, допускающих использование регулярных выражений.

// Директива listen позволяет указать не только порт, но и IP-адрес, к которому привязываются запросы:
// server {
//  listen 192.168.0.1:80;
//  server_name example.org www.example.org;
//  ...
// }

// root - определяет физическое расположение виртуального хоста на жестком диске
// server {
//  listen 80;
//  server_name example.org www.example.org;
//  root /var/lib/www/example.org/www;
//  ...
// }

// error_page - позволяет указать путь к файлу, который возвращается при передаче определенного HTTP-кода состояния
// server {
//  ...
//  error_page 404 /404.html;
//  error_page 500 /500.html;
//  ...
// }

// index позволяет задать индексный файл
// server {
//  ...
//  index index.html;
//  ...
// }

// Для того чтобы активировать конфигурационный файл, в папке /etc/nginx/sites-enabled/ необходимо создать символическую ссылку
// $ sudo ln -s /etc/nginx/sites-available/example.com /etc/nginx/ sites-enabled/example.com

// Журнальные файлы
// Директивы журнальных файлов
// error_log - Записываются сообщения об ошибках
// access_log - Записываются сообщения об обращениях к серверу
// log_format - Задает формат журнальных файлов

// log_format '$remote_addr|$time_local|$request|$status|$http_user_agent';

// Встроенные переменные nginx
// $arg_name - Аргумент name в строке запроса
// $args - Аргументы в строке запроса
// $binary_remote_addr - Адрес клиента в бинарном виде, длина значения всегда 4 байта
// $body_bytes_sent - Количество байтов, переданных клиенту, без учета заголовка ответа
// $bytes_sent - Количество байтов, переданных клиенту
// $connection - Порядковый номер соединения
// $connection_requests - Текущее количество запросов в соединении
// $content_length - Содержимое HTTP-заголовка Content-Length
// $content_type - Содержимое HTTP-заголовка Content-Type
// $cookie_name - Содержимое cookie с именем name
// $document_root - Содержимое директивы $root
// $document_uri - Синоним для $uri
// $host - Имя хоста из строки запроса, или имя хоста из HTTP-заголовка Host, или имя сервера, соответствующего запросу
// $hostname - Имя хоста
// $http_name - Содержимое HTTP-заголовка name, полученного от клиента; последняя часть имени переменной соответствует имени поля, приведенного к нижнему регистру, с заменой символов тире символами подчеркивания, например, HTTP-заголовку User-Agent соответствует переменная $http_user_agent
// $https - Принимает значение "on", если соединение работает в режиме SSL, иначе переменная содержит пустую строку
// $is_args - Принимает значение "?", если в строке запроса есть аргументы, иначе переменная содержит пустую строку
// $limit_rate - Ограничение скорости ответа (см. табл. 55.2)
// $msec - Время в секундах с точностью до миллисекунд
// $nginx_version - Версия nginx
// $pid - Идентификатор (PID) рабочего процесса
// $pipe - "p", если запрос был pipelined, иначе "."
// $query_string - Синоним для $args
// $realpath_root - Абсолютный путь, соответствующий значению директивы $root для текущего запроса, в котором все символические ссылки преобразованы в реальные пути
// $remote_addr - IP-адрес клиента
// $remote_port - Порт клиента
// $remote_user - Имя пользователя, использованное в Basic-аутентификации
// $request - Первоначальная строка запроса
// $request_body - Тело запроса
// $request_body_file - Имя временного файла, в котором хранится тело запроса
// $request_completion - Строка "OK", если запрос завершился, либо пустая строка
// $request_filename - Путь к файлу для текущего запроса, формируемый из директивы $root и URI запроса
// $request_length - Длина запроса (включая строку запроса, заголовок и тело запроса)
// $request_method - Метод запроса: "GET", "POST", "HEAD"
// $request_time - Время обработки запроса в секундах с точностью до миллисекунд; время, прошедшее с момента чтения первых байтов от клиента до момента записи в лог после отправки последних байтов клиенту
// $request_uri - Первоначальный URI запроса целиком (с аргументами)
// $scheme - Схема запроса: "http" или "https"
// $sent_http_name - Содержимое HTTP-заголовка name, отправленного сервером клиенту; последняя часть имени переменной соответствует имени поля, приведенного к нижнему регистру, с заменой символов тире символами подчеркивания
// $server_addr - IP-адрес сервера, принявшего запрос
// $server_name - Имя сервера, принявшего запрос
// $server_port - Порт сервера, принявшего запрос
// $server_protocol - Версия HTTP протокола запроса, обычно "HTTP/1.0" или "HTTP/1.1"
// $status - Код HTTP-ответа
// $time_iso8601 - Локальное время в формате по стандарту ISO 8601
// $time_local - Локальное время в Common Log Format
// $uri - Текущий URI запроса в нормализованном виде; значение $uri может изменяться в процессе обработки запроса, например, при внутренних перенаправлениях или при использовании индексных файлов

// Местоположения
// Модификаторы секции location
// = Буквальное сравнение
// ~ Сопоставление с регулярным выражением с учетом регистра
// ~* Сопоставление с регулярным выражением без учета регистра
// ^~ По умолчанию nginx подбирает сопоставления с самым длинным префиксом. При использовании данной комбинации, в случае нахождения соответствия, дальнейший поиск прекращается



// ГЛАВА 56. PHP-FPM

// Установка
// $ sudo apt-get update
// $ sudo apt-get upgrade
// $ sudo apt-get install php7-fpm

// Управление сервером
// $ sudo service php7-fpm start
// $ sudo service php7-fpm stop
// $ sudo service php7-fpm restart
// $ sudo service php7-fpm reload
// $ ps aux | grep php-fpm

// Конфигурационные файлы

// Подключение к Web-серверу nginx



// ГЛАВА 57. Администрирование MySQL

// Установка
// $ sudo apt-get install mysql-server
// $ sudo mysql_secure_installation

// Управление сервером
// $ sudo service mysql start
// $ sudo service mysql stop
// $ sudo service mysql restar
// $ sudo service mysql reload
// $ ps aux | grep mysqld

// Конфигурационный файл сервера

// Секции конфигурационного файла my.cnf
// [mysqld] - Сервер MySQL
// [server] - Сервер MySQL
// [mysqld-5.6] - Сервер MySQL версии 5.6
// [mysqld_safe] - Утилита запуска mysqld_safe
// [client] - Любая клиентская утилита, обращающаяся к серверу
// [mysql] - Консольный клиент mysql
// [mysqldump] - Утилита создания SQL-дампов mysqldump
// [mysqlhotcopy] - Утилита "горячего" копирования бинарных файлов базы данных

// Выделение памяти MySQL
// mysql> SHOW STATUS LIKE 'Key%';
// mysql> SHOW STATUS LIKE 'Innodb_buffer_pool_%';

// Пользовательский конфигурационный файл

// Создание MySQL-пользователей

// Удаленный доступ к MySQL

// Привилегии

// Восстановление утерянного пароля

// Перенос баз данных с одного сервера на другой

// Создание SQL-дампа
// $ mysqldump base > base.sql
// $ mysqldump --all-databases > all_databases.sql

// Развернуть SQL-дамп на другом сервере
// $ mysql test < base.sql
// mysql> SOURCE base.sql;








